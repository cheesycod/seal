local pathlib = require("./path")
local datetime = require("@std/time/datetime")

export type Fs = {
	readfile: (path: string) -> string,
	readbytes: (path: string, target_buffer: buffer, buffer_offset: number?, file_offset: number?, count: number?) -> (),
	readlines: (path: string) -> () -> (number, string),

	writefile: (path: string, content: string | buffer) -> (),
	removefile: (path: string) -> (),

	readtree: (path: string) -> DirectoryTree,
	writetree: (path: string, children: DirectoryTree) -> (),
	removetree: (path: string) -> (),

	makedir: (path: string) -> (),
	listdir: (path: string, recursive: boolean?) -> { string },

	move: (from: string, to: string) -> (),
	copy: (source: string, destination: string) -> (),

	find: (path: string, follow_symlinks: boolean?) -> FindResult,
	entries: (path: string) -> { [string]: Entry },

	file: {
		from: (path: string) -> FileEntry,
		build: (name: string, content: string) -> FileBuilder,
		create: (path: string) -> FileEntry,
	},

	dir: {
		from: (path: string) -> DirectoryEntry,
		build: (name: string, children: DirectoryTree) -> DirectoryBuilder,
		create: (path: string) -> DirectoryEntry,
	},

	path: pathlib.PathLib,
}

export type FileEntry = {
	name: string,
	path: string,
	type: "File",
	read: (self: FileEntry) -> string,
	size: (self: FileEntry) -> number,
	readbytes: (self: FileEntry, target_buffer: buffer, buffer_offset: number?, file_offset: number?, count: number?) -> (),
	readlines: (self: FileEntry) -> () -> (number, string),
	append: (self: FileEntry, content: buffer | string) -> (),
	is_valid_utf8: (self: FileEntry) -> boolean,
	metadata: (self: FileEntry) -> FsMetadata,
	copy_to: (self: FileEntry, to: string) -> (),
	move_to: (self: FileEntry, to: string) -> (),
	rename: (self: FileEntry, name: string) -> (),
	remove: (self: FileEntry) -> (),
}

export type DirectoryEntry = {
	name: string,
	path: string,
	type: "Directory",
	list: (self: DirectoryEntry, recursive: boolean?) -> { string },
	find: (self: DirectoryEntry, name: string, follow_symlinks: boolean?) -> FindResult,
	entries: (self: DirectoryEntry) -> { [string]: Entry },
	expect_file: (self: DirectoryEntry, name: string) -> FileEntry,
	expect_dir: (self: DirectoryEntry, name: string) -> DirectoryEntry,
	write_children: (self: DirectoryEntry, children: DirectoryTree) -> (),
	metadata: (self: DirectoryEntry) -> FsMetadata,
	copy_to: (self: DirectoryEntry, to: string) -> (),
	move_to: (self: DirectoryEntry, to: string) -> (),
	rename: (self: DirectoryEntry, name: string) -> (),
	remove: (self: DirectoryEntry) -> (),
}

export type Entry = FileEntry | DirectoryEntry

export type FsMetadata = {
	created_at: datetime.DateTimeUtc?,
	modified_at: datetime.DateTimeUtc?,
	accessed_at: datetime.DateTimeUtc?,
	permissions: {
		readonly: boolean,
		unix_mode: number?,
	}
}

export type FindResult = { -- can't make this type more accurate w/ unions bc it breaks (new) typesolver
	ok: boolean,
	exists: (self: FindResult) -> boolean,
	file: FileEntry?,
	dir: DirectoryEntry?,
	unwrap_file: (self: FindResult) -> FileEntry,
	unwrap_dir: (self: FindResult) -> DirectoryEntry,
	err: ("NotFound" | "PermissionDenied")?
}

type FileBuilder = {
	name: string,
	type: "File",
	content: string,
}

type DirectoryBuilder = {
	name: string,
	type: "Directory",
	children: DirectoryTree,
}

export type DirectoryTree = {
	FileBuilder | DirectoryBuilder
}

local fs = {} :: Fs

local file = fs.find("./src/require.rs"):unwrap_file()
for path, entry in fs.entries("./src") do
	if entry.type == "File" then
		local content = entry:read()
	end
end

return {} :: Fs